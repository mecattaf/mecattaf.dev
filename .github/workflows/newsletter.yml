name: Newsletter Automation

on:
  push:
    branches: [ main ]
    paths: [ 'content/blog/**' ]

jobs:
  newsletter:
    runs-on: ubuntu-latest
    
    # Only run if commit message contains [Newsletter] or [Draft]
    if: contains(github.event.head_commit.message, '[Newsletter]') || contains(github.event.head_commit.message, '[Draft]')
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Need previous commit to detect changes
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: |
        npm install axios gray-matter
    
    - name: Process blog post and send newsletter
      env:
        CONVERTKIT_API_KEY: ${{ secrets.CONVERTKIT_API_KEY }}
        CONVERTKIT_API_SECRET: ${{ secrets.CONVERTKIT_API_SECRET }}
      run: |
        cat > newsletter-processor.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const axios = require('axios');
        const matter = require('gray-matter');

        async function main() {
          try {
            console.log('üöÄ Starting newsletter automation...');
            
            // Check commit message for action type
            const commitMessage = process.env.GITHUB_EVENT_HEAD_COMMIT_MESSAGE || '';
            const isDraft = commitMessage.includes('[Draft]');
            const isNewsletter = commitMessage.includes('[Newsletter]');
            
            if (!isDraft && !isNewsletter) {
              console.log('‚ùå No newsletter trigger found in commit message');
              return;
            }
            
            console.log(`üìù Mode: ${isDraft ? 'Draft' : 'Send Newsletter'}`);
            
            // Find the most recently modified blog post (excluding files starting with _)
            const blogDir = 'content/blog';
            const blogFiles = fs.readdirSync(blogDir)
              .filter(file => file.endsWith('.md') && !file.startsWith('_'))
              .map(file => {
                const filePath = path.join(blogDir, file);
                const stats = fs.statSync(filePath);
                return { file, path: filePath, mtime: stats.mtime };
              })
              .sort((a, b) => b.mtime - a.mtime);
            
            if (blogFiles.length === 0) {
              console.log('‚ùå No blog posts found');
              return;
            }
            
            const latestPost = blogFiles[0];
            console.log(`üìÑ Processing: ${latestPost.file}`);
            
            // Parse the blog post (Hugo uses TOML frontmatter with +++)
            const fileContent = fs.readFileSync(latestPost.path, 'utf8');
            
            let frontMatter = {};
            let content = fileContent;
            
            // Parse TOML frontmatter manually since gray-matter expects YAML by default
            const frontMatterMatch = fileContent.match(/^\+\+\+\n([\s\S]*?)\n\+\+\+\n([\s\S]*)$/);
            if (frontMatterMatch) {
              const frontMatterText = frontMatterMatch[1];
              content = frontMatterMatch[2];
              
              // Enhanced TOML parser for the fields we need
              frontMatterText.split('\n').forEach(line => {
                // Handle quoted strings
                const quotedMatch = line.match(/^(\w+)\s*=\s*"([^"]*)"$/);
                if (quotedMatch) {
                  frontMatter[quotedMatch[1]] = quotedMatch[2];
                  return;
                }
                
                // Handle unquoted strings/numbers
                const unquotedMatch = line.match(/^(\w+)\s*=\s*(.+)$/);
                if (unquotedMatch) {
                  frontMatter[unquotedMatch[1]] = unquotedMatch[2].trim();
                }
              });
            }
            
            // Convert markdown to HTML for email
            const emailContent = convertMarkdownToHTML(content, frontMatter.title || 'New Blog Post', frontMatter.slug, frontMatter.date);
            
            // Prepare newsletter data
            const subject = frontMatter.title || 'New Blog Post';
            
            console.log(`üìß Subject: ${subject}`);
            console.log(`üìù Content length: ${emailContent.length} characters`);
            
            // Send to ConvertKit
            await sendToConvertKit(subject, emailContent, isDraft);
            
          } catch (error) {
            console.error('‚ùå Error:', error.message);
            process.exit(1);
          }
        }

        function convertMarkdownToHTML(markdown, title, slug, date) {
          // Generate the blog post URL based on Hugo's permalink structure
          // From config.toml: blog = "/blog/:year/:slug/"
          let blogUrl = 'https://mecattaf.dev/blog/';
          
          if (date && slug) {
            // Extract year from date (format: "2025-06-01T00:00:00+02:00")
            const year = date.split('-')[0];
            blogUrl += `${year}/${slug}/`;
          }
          
          // Start with the title as H1 with proper styling and hyperlink
          let html = `<h1 style="font-size: 28px; font-weight: bold; margin: 20px 0; color: #333;"><a href="${blogUrl}" style="color: inherit; text-decoration: none;">${title}</a></h1>\n\n`;
          
          // Process the markdown content
          let content = markdown
            // Remove Hugo comments
            .replace(/<!--[\s\S]*?-->/g, '')
            // Remove Hugo shortcodes
            .replace(/\{\{[^}]+\}\}/g, '')
            // Convert headers with inline styles for better email rendering
            .replace(/^#{1}\s+(.+)$/gm, '<h2 style="font-size: 24px; font-weight: bold; margin: 20px 0 10px 0; color: #333;">$1</h2>')
            .replace(/^#{2}\s+(.+)$/gm, '<h3 style="font-size: 20px; font-weight: bold; margin: 18px 0 8px 0; color: #333;">$1</h3>')
            .replace(/^#{3}\s+(.+)$/gm, '<h4 style="font-size: 18px; font-weight: bold; margin: 16px 0 6px 0; color: #333;">$1</h4>')
            .replace(/^#{4}\s+(.+)$/gm, '<h5 style="font-size: 16px; font-weight: bold; margin: 14px 0 4px 0; color: #333;">$1</h5>')
            .replace(/^#{5,6}\s+(.+)$/gm, '<h6 style="font-size: 14px; font-weight: bold; margin: 12px 0 2px 0; color: #333;">$1</h6>')
            // Convert code blocks to proper HTML with styling
            .replace(/```([\w]*)\n([\s\S]*?)```/g, '<pre style="background: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; margin: 10px 0;"><code>$2</code></pre>')
            // Convert inline code with styling
            .replace(/`([^`]+)`/g, '<code style="background: #f0f0f0; padding: 2px 4px; border-radius: 3px; font-family: monospace;">$1</code>')
            // Convert bold text 
            .replace(/\*\*([^*\n]+)\*\*/g, '<strong>$1</strong>')
            // Convert italic text 
            .replace(/\*([^*\n]+)\*/g, '<em>$1</em>')
            // Convert links to proper HTML anchors with styling
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" style="color: #0066cc; text-decoration: underline;">$1</a>')
            // Convert images to proper HTML with absolute URLs
            .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, src) => {
              // Convert relative URLs to absolute URLs for email compatibility
              let absoluteSrc = src;
              
              // If it's a relative path, make it absolute
              if (src.startsWith('/')) {
                absoluteSrc = `https://mecattaf.dev${src}`;
              }
              // If it's already a full URL, keep it as is
              else if (!src.startsWith('http')) {
                // Handle other relative paths (without leading slash)
                absoluteSrc = `https://mecattaf.dev/${src}`;
              }
              
              return `<img src="${absoluteSrc}" alt="${alt}" style="max-width: 100%; height: auto; display: block; margin: 10px 0;" />`;
            });

          // Process lists separately to handle them properly
          const lines = content.split('\n');
          const processedLines = [];
          let inList = false;
          let listItems = [];

          for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const isListItem = /^[\s]*[-*+]\s+(.+)$/.test(line);
            
            if (isListItem) {
              if (!inList) {
                inList = true;
                listItems = [];
              }
              const match = line.match(/^[\s]*[-*+]\s+(.+)$/);
              if (match) {
                listItems.push(`<li style="margin: 5px 0; padding-left: 5px;">${match[1]}</li>`);
              }
            } else {
              if (inList) {
                // End of list, wrap it
                processedLines.push(`<ul style="margin: 10px 0; padding-left: 20px;">\n${listItems.join('\n')}\n</ul>`);
                inList = false;
                listItems = [];
              }
              if (line.trim()) {
                processedLines.push(line);
              } else {
                processedLines.push(''); // Preserve empty lines
              }
            }
          }

          // Don't forget the last list if the content ends with one
          if (inList) {
            processedLines.push(`<ul style="margin: 10px 0; padding-left: 20px;">\n${listItems.join('\n')}\n</ul>`);
          }

          // Join lines back and process paragraphs
          content = processedLines.join('\n');

          // Convert paragraphs - split by double newlines and wrap in p tags
          const paragraphs = content.split(/\n\s*\n/);
          const processedParagraphs = paragraphs.map(paragraph => {
            paragraph = paragraph.trim();
            
            // Skip if empty
            if (!paragraph) {
              return '';
            }
            
            // Skip if it's already wrapped in HTML tags
            if (paragraph.match(/^<(h[1-6]|ul|ol|pre|blockquote|div|li)/i)) {
              return paragraph;
            }
            
            // Don't wrap single lines that are just HTML tags
            if (paragraph.match(/^<\/?(h[1-6]|ul|ol|pre|blockquote|div)>/i)) {
              return paragraph;
            }
            
            // Wrap in paragraph tags with styling
            return `<p style="margin: 10px 0; line-height: 1.6;">${paragraph}</p>`;
          }).filter(p => p !== '');

          return html + processedParagraphs.join('\n\n');
        }

        async function sendToConvertKit(subject, content, isDraft) {
          const apiKey = process.env.CONVERTKIT_API_KEY;
          const apiSecret = process.env.CONVERTKIT_API_SECRET;
          
          if (!apiKey || !apiSecret) {
            throw new Error('ConvertKit API credentials not found');
          }
          
          // Create broadcast
          const broadcastData = {
            api_secret: apiSecret,
            subject: subject,
            content: content,
            description: `Newsletter: ${subject}`,
            public: !isDraft  // If draft, don't make public yet
          };
          
          console.log('üì§ Creating broadcast in ConvertKit...');
          
          const response = await axios.post(
            `https://api.convertkit.com/v3/broadcasts?api_key=${apiKey}`,
            broadcastData,
            {
              headers: {
                'Content-Type': 'application/json'
              }
            }
          );
          
          const broadcastId = response.data.broadcast.id;
          console.log(`‚úÖ Broadcast created with ID: ${broadcastId}`);
          
          if (!isDraft) {
            // Send the broadcast immediately
            console.log('üì¨ Sending newsletter...');
            
            await axios.post(
              `https://api.convertkit.com/v3/broadcasts/${broadcastId}/send?api_key=${apiKey}`,
              { api_secret: apiSecret },
              {
                headers: {
                  'Content-Type': 'application/json'
                }
              }
            );
            
            console.log('üéâ Newsletter sent successfully!');
          } else {
            console.log('üìù Draft created in ConvertKit for review');
            console.log(`üîó Review at: https://app.convertkit.com/broadcasts/${broadcastId}`);
          }
        }

        // Add commit message to environment
        const { execSync } = require('child_process');
        try {
          const commitMsg = execSync('git log -1 --pretty=%B', { encoding: 'utf8' }).trim();
          process.env.GITHUB_EVENT_HEAD_COMMIT_MESSAGE = commitMsg;
        } catch (e) {
          console.log('Could not get commit message, using GitHub event');
        }

        main();
        EOF
        
        node newsletter-processor.js
    
    - name: Cleanup
      run: rm -f newsletter-processor.js
