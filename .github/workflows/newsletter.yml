name: Newsletter Automation

on:
  push:
    branches: [ main ]
    paths: [ 'content/blog/**' ]

jobs:
  newsletter:
    runs-on: ubuntu-latest
    
    # Only run if commit message contains [Newsletter] or [Draft]
    if: contains(github.event.head_commit.message, '[Newsletter]') || contains(github.event.head_commit.message, '[Draft]')
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 2  # Need previous commit to detect changes
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install dependencies
      run: |
        npm install axios gray-matter
    
    - name: Process blog post and send newsletter
      env:
        CONVERTKIT_API_KEY: ${{ secrets.CONVERTKIT_API_KEY }}
        CONVERTKIT_API_SECRET: ${{ secrets.CONVERTKIT_API_SECRET }}
      run: |
        cat > newsletter-processor.js << 'EOF'
        const fs = require('fs');
        const path = require('path');
        const axios = require('axios');
        const matter = require('gray-matter');

        async function main() {
          try {
            console.log('üöÄ Starting newsletter automation...');
            
            // Check commit message for action type
            const commitMessage = process.env.GITHUB_EVENT_HEAD_COMMIT_MESSAGE || '';
            const isDraft = commitMessage.includes('[Draft]');
            const isNewsletter = commitMessage.includes('[Newsletter]');
            
            if (!isDraft && !isNewsletter) {
              console.log('‚ùå No newsletter trigger found in commit message');
              return;
            }
            
            console.log(`üìù Mode: ${isDraft ? 'Draft' : 'Send Newsletter'}`);
            
            // Find the most recently modified blog post (excluding files starting with _)
            const blogDir = 'content/blog';
            const blogFiles = fs.readdirSync(blogDir)
              .filter(file => file.endsWith('.md') && !file.startsWith('_'))
              .map(file => {
                const filePath = path.join(blogDir, file);
                const stats = fs.statSync(filePath);
                return { file, path: filePath, mtime: stats.mtime };
              })
              .sort((a, b) => b.mtime - a.mtime);
            
            if (blogFiles.length === 0) {
              console.log('‚ùå No blog posts found');
              return;
            }
            
            const latestPost = blogFiles[0];
            console.log(`üìÑ Processing: ${latestPost.file}`);
            
            // Parse the blog post (Hugo uses TOML frontmatter with +++)
            const fileContent = fs.readFileSync(latestPost.path, 'utf8');
            
            let frontMatter = {};
            let content = fileContent;
            
            // Parse TOML frontmatter manually since gray-matter expects YAML by default
            const frontMatterMatch = fileContent.match(/^\+\+\+\n([\s\S]*?)\n\+\+\+\n([\s\S]*)$/);
            if (frontMatterMatch) {
              const frontMatterText = frontMatterMatch[1];
              content = frontMatterMatch[2];
              
              // Simple TOML parser for the fields we need
              frontMatterText.split('\n').forEach(line => {
                const match = line.match(/^(\w+)\s*=\s*"([^"]*)"$/);
                if (match) {
                  frontMatter[match[1]] = match[2];
                }
              });
            }
            
            // Convert markdown to HTML for email
            const emailContent = convertMarkdownToHTML(content, frontMatter.title || 'New Blog Post');
            
            // Prepare newsletter data
            const subject = frontMatter.title || 'New Blog Post';
            
            console.log(`üìß Subject: ${subject}`);
            console.log(`üìù Content length: ${emailContent.length} characters`);
            
            // Send to ConvertKit
            await sendToConvertKit(subject, emailContent, isDraft);
            
          } catch (error) {
            console.error('‚ùå Error:', error.message);
            process.exit(1);
          }
        }

        function convertMarkdownToHTML(markdown, title) {
          // Start with the title as H1
          let html = `<h1>${title}</h1>\n\n`;
          
          return html + markdown
            // Remove Hugo comments
            .replace(/<!--[\s\S]*?-->/g, '')
            // Remove Hugo shortcodes
            .replace(/\{\{[^}]+\}\}/g, '')
            // Convert headers (# becomes h2, ## becomes h3, etc.)
            .replace(/^#{1}\s+(.+)$/gm, '<h2>$1</h2>')
            .replace(/^#{2}\s+(.+)$/gm, '<h3>$1</h3>')
            .replace(/^#{3}\s+(.+)$/gm, '<h4>$1</h4>')
            .replace(/^#{4}\s+(.+)$/gm, '<h5>$1</h5>')
            .replace(/^#{5,6}\s+(.+)$/gm, '<h6>$1</h6>')
            // Convert code blocks to proper HTML
            .replace(/```([\w]*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
            // Convert inline code
            .replace(/`([^`]+)`/g, '<code>$1</code>')
            // Convert bold text 
            .replace(/\*\*([^*\n]+)\*\*/g, '<strong>$1</strong>')
            // Convert italic text 
            .replace(/\*([^*\n]+)\*/g, '<em>$1</em>')
            // Convert links to proper HTML anchors
            .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
            // Convert unordered lists
            .replace(/^[\s]*[-*+]\s+(.+)$/gm, '<li>$1</li>')
            // Wrap consecutive list items in ul tags
            .replace(/(<li>.*<\/li>)/gs, (match) => {
              const items = match.split('</li>').filter(item => item.trim()).map(item => item + '</li>');
              return '<ul>\n' + items.join('\n') + '\n</ul>';
            })
            // Convert ordered lists
            .replace(/^[\s]*\d+\.\s+(.+)$/gm, '<li>$1</li>')
            // Fix any double ul/ol wrapping that might have occurred
            .replace(/<\/ul>\s*<ul>/g, '')
            .replace(/<\/ol>\s*<ol>/g, '')
            // Convert paragraphs - split by double newlines and wrap in p tags
            .split(/\n\s*\n/)
            .map(paragraph => {
              paragraph = paragraph.trim();
              // Skip if it's already wrapped in HTML tags or empty
              if (!paragraph || 
                  paragraph.match(/^<(h[1-6]|ul|ol|pre|blockquote|div)/i) ||
                  paragraph.match(/<\/(h[1-6]|ul|ol|pre|blockquote|div)>$/i)) {
                return paragraph;
              }
              // Don't wrap standalone list items
              if (paragraph.match(/^<li>.*<\/li>$/)) {
                return paragraph;
              }
              return `<p>${paragraph}</p>`;
            })
            .join('\n\n')
            // Clean up extra whitespace
            .replace(/\n{3,}/g, '\n\n')
            .trim();
        }

        async function sendToConvertKit(subject, content, isDraft) {
          const apiKey = process.env.CONVERTKIT_API_KEY;
          const apiSecret = process.env.CONVERTKIT_API_SECRET;
          
          if (!apiKey || !apiSecret) {
            throw new Error('ConvertKit API credentials not found');
          }
          
          // Create broadcast
          const broadcastData = {
            api_secret: apiSecret,
            subject: subject,
            content: content,
            description: `Newsletter: ${subject}`,
            public: !isDraft  // If draft, don't make public yet
          };
          
          console.log('üì§ Creating broadcast in ConvertKit...');
          
          const response = await axios.post(
            `https://api.convertkit.com/v3/broadcasts?api_key=${apiKey}`,
            broadcastData,
            {
              headers: {
                'Content-Type': 'application/json'
              }
            }
          );
          
          const broadcastId = response.data.broadcast.id;
          console.log(`‚úÖ Broadcast created with ID: ${broadcastId}`);
          
          if (!isDraft) {
            // Send the broadcast immediately
            console.log('üì¨ Sending newsletter...');
            
            await axios.post(
              `https://api.convertkit.com/v3/broadcasts/${broadcastId}/send?api_key=${apiKey}`,
              { api_secret: apiSecret },
              {
                headers: {
                  'Content-Type': 'application/json'
                }
              }
            );
            
            console.log('üéâ Newsletter sent successfully!');
          } else {
            console.log('üìù Draft created in ConvertKit for review');
            console.log(`üîó Review at: https://app.convertkit.com/broadcasts/${broadcastId}`);
          }
        }

        // Add commit message to environment
        const { execSync } = require('child_process');
        try {
          const commitMsg = execSync('git log -1 --pretty=%B', { encoding: 'utf8' }).trim();
          process.env.GITHUB_EVENT_HEAD_COMMIT_MESSAGE = commitMsg;
        } catch (e) {
          console.log('Could not get commit message, using GitHub event');
        }

        main();
        EOF
        
        node newsletter-processor.js
    
    - name: Cleanup
      run: rm -f newsletter-processor.js
